// src/components/debug/TicketReopenTester.jsx
import React, { useState } from 'react';
import { ref, update, push, get } from 'firebase/database';
import { database } from '@/config/firebase';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useToast } from "@/components/ui/use-toast";
import { useAuth } from '@/components/auth/AuthProvider';
import FirebaseDebugHelper from '@/utils/firebaseDebugHelper';
import TicketOperations from '@/services/ticketOperations';

/**
 * A utility component to test ticket reopening functionality
 * Useful for debugging admin functionality issues
 */
const TicketReopenTester = () => {
    const [ticketId, setTicketId] = useState('');
    const [testResults, setTestResults] = useState(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const { user, userRole } = useAuth();
    const { toast } = useToast();

    // Only show in development
    if (process.env.NODE_ENV !== 'development') {
        return null;
    }

    const runDirectUpdateTest = async () => {
        if (!ticketId) {
            toast({
                title: "Error",
                description: "Please enter a ticket ID",
                variant: "destructive"
            });
            return;
        }

        setIsProcessing(true);
        setTestResults(null);

        try {
            // First, read the ticket to check if it exists and is completed
            const ticketRef = ref(database, `tickets/${ticketId}`);
            const snapshot = await get(ticketRef);

            if (!snapshot.exists()) {
                setTestResults({
                    success: false,
                    message: `Ticket ${ticketId} does not exist`,
                    phase: 'read'
                });
                toast({
                    title: "Error",
                    description: `Ticket ${ticketId} does not exist`,
                    variant: "destructive"
                });
                return;
            }

            const ticket = snapshot.val();
            setTestResults({
                initialRead: {
                    success: true,
                    ticketData: ticket
                },
                phase: 'read',
                message: `Successfully read ticket: ${ticket.ticketId || ticketId}, status: ${ticket.status}`
            });

            // Update the ticket directly - bypass any checks
            const updates = {
                status: 'in-progress',
                completedAt: null,
                reopenedAt: new Date().toISOString(),
                reopenedBy: 'debug-tester',
                lastUpdated: new Date().toISOString(),
                skipEmailNotification: true
            };

            await update(ticketRef, updates);

            // Update test results
            setTestResults(prev => ({
                ...prev,
                directUpdate: {
                    success: true,
                    updates
                },
                phase: 'update',
                message: `Successfully updated ticket status to in-progress`
            }));

            // Add a comment about the reopen
            const commentsRef = ref(database, `tickets/${ticketId}/comments`);
            await push(commentsRef, {
                content: "Ticket reopened by debug tester component",
                user: 'Debug Tester',
                userEmail: 'debug@test.com',
                timestamp: new Date().toISOString(),
                isSystemComment: true
            });

            // Final success status
            setTestResults(prev => ({
                ...prev,
                comment: {
                    success: true
                },
                phase: 'complete',
                message: `Successfully reopened ticket ${ticketId}`,
                success: true
            }));

            toast({
                title: "Success",
                description: `Ticket ${ticketId} has been reopened`,
                variant: "success"
            });
        } catch (error) {
            console.error('Error in reopen test:', error);

            // Update test results with error
            setTestResults(prev => ({
                ...prev,
                error: {
                    message: error.message,
                    stack: error.stack,
                    code: error.code
                },
                phase: 'error',
                message: `Error: ${error.message}`,
                success: false
            }));

            toast({
                title: "Error",
                description: `Failed to reopen ticket: ${error.message}`,
                variant: "destructive"
            });
        } finally {
            setIsProcessing(false);
        }
    };

    const useTicketOperationsModule = async () => {
        if (!ticketId) {
            toast({
                title: "Error",
                description: "Please enter a ticket ID",
                variant: "destructive"
            });
            return;
        }

        setIsProcessing(true);
        setTestResults(null);

        try {
            // Use the TicketOperations module
            const result = await TicketOperations.reopenTicket(
                ticketId,
                {
                    uid: user?.uid || 'debug-tester',
                    role: 'Debug Tester',
                    email: user?.email || 'debug@test.com'
                }
            );

            setTestResults({
                moduleTest: result,
                phase: 'complete',
                message: result.message,
                success: result.success
            });

            if (result.success) {
                toast({
                    title: "Success",
                    description: result.message,
                    variant: "success"
                });
            } else {
                toast({
                    title: "Error",
                    description: result.message,
                    variant: "destructive"
                });
            }
        } catch (error) {
            console.error('Error in module test:', error);

            setTestResults({
                error: {
                    message: error.message,
                    stack: error.stack
                },
                phase: 'error',
                message: `Error: ${error.message}`,
                success: false
            });

            toast({
                title: "Error",
                description: `Unexpected error: ${error.message}`,
                variant: "destructive"
            });
        } finally {
            setIsProcessing(false);
        }
    };

    const runFirebaseDiagnostics = async () => {
        setIsProcessing(true);
        setTestResults(null);

        try {
            const results = await FirebaseDebugHelper.runDiagnostics();

            setTestResults({
                diagnostics: results,
                phase: 'diagnostics',
                message: 'Completed Firebase diagnostics',
                success: true
            });

            toast({
                title: "Diagnostics Complete",
                description: "Check the console for detailed results",
                variant: "info"
            });
        } catch (error) {
            console.error('Error running diagnostics:', error);

            setTestResults({
                error: {
                    message: error.message,
                    stack: error.stack
                },
                phase: 'error',
                message: `Error: ${error.message}`,
                success: false
            });

            toast({
                title: "Error",
                description: `Diagnostics failed: ${error.message}`,
                variant: "destructive"
            });
        } finally {
            setIsProcessing(false);
        }
    };

    // Helper to display a readable version of test results
    const formatResults = (results) => {
        if (!results) return 'No results';

        try {
            return JSON.stringify(results, null, 2);
        } catch (error) {
            return `Error formatting results: ${error.message}`;
        }
    };

    return (
        <div className="fixed top-4 left-4 z-50 bg-black bg-opacity-90 text-white p-4 rounded-lg w-96 max-h-[90vh] overflow-auto opacity-75 hover:opacity-100 transition-opacity">
            <h2 className="text-lg font-bold mb-4">Ticket Reopen Tester</h2>

            <div className="space-y-4">
                <div>
                    <label className="block text-sm mb-1">Ticket ID (Firebase key)</label>
                    <Input
                        value={ticketId}
                        onChange={(e) => setTicketId(e.target.value)}
                        placeholder="Enter ticket ID"
                        className="bg-gray-800 text-white border-gray-700"
                    />
                </div>

                <div className="flex flex-col space-y-2">
                    <Button
                        onClick={runDirectUpdateTest}
                        disabled={isProcessing || !ticketId}
                        className="bg-red-800 hover:bg-red-700 text-white"
                    >
                        Direct Reopen Test
                    </Button>

                    <Button
                        onClick={useTicketOperationsModule}
                        disabled={isProcessing || !ticketId}
                        className="bg-blue-800 hover:bg-blue-700 text-white"
                    >
                        Use TicketOperations Module
                    </Button>

                    <Button
                        onClick={runFirebaseDiagnostics}
                        disabled={isProcessing}
                        className="bg-green-800 hover:bg-green-700 text-white"
                    >
                        Run Firebase Diagnostics
                    </Button>
                </div>

                {isProcessing && (
                    <div className="text-yellow-400 animate-pulse">
                        Processing...
                    </div>
                )}

                {testResults && (
                    <div className="mt-4">
                        <h3 className="text-md font-semibold mb-2">
                            Test Results:
                            <span className={testResults.success ? 'text-green-400' : 'text-red-400'}>
                                {testResults.success ? ' Success' : ' Failed'}
                            </span>
                        </h3>
                        <p className="text-sm mb-2">{testResults.message}</p>

                        <div className="bg-gray-900 p-2 rounded text-xs font-mono overflow-auto max-h-60">
                            {formatResults(testResults)}
                        </div>
                    </div>
                )}

                <div className="text-xs text-gray-400 mt-4">
                    <p>User: {user?.email || 'Not signed in'}</p>
                    <p>Role: {userRole || 'None'}</p>
                    <p>Admin: {TicketOperations.isUserAdmin(user, userRole) ? 'Yes' : 'No'}</p>
                </div>
            </div>
        </div>
    );
};

export default TicketReopenTester;